<html>
<head>
  <title>Final Project</title>
  <style>
    body {
      margin: 0
    };
    canvas {
      width: 100%, height: 100%
    };
  </style>
</head>

<body>
</script>
  <script src="js/build/three.js"></script>
  <!--script src="js/build/three.module.js"></script-->
  <script src="js/controls/OrbitControls.js"></script>
  <script src="js/modifiers/TessellateModifier.js"></script>
  <script src="js/objects/Water2.js"></script>
  <script src="js/objects/Reflector.js"></script>
  <script src="js/loaders/OBJLoader.js"></script>
  <script src="js/objects/Refractor.js"></script>
  <!--script src="js/objects/Water.js"></script-->

  <script>

    var camera, scene, renderer, object;
    var pLight1, pLight2;
    var orbitable;
    var clock = new THREE.Clock();
    var time = Date.now() * 0.0025;
    var torusObj, sphereRadius;
    var water;
    var animation;

    //helper function
    function randomInt (min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    //helper function
    function randomFloat(min, max) {
      return Math.random() * (max - min ) + min;
    }


    function init() {
      //scene
      scene = new THREE.Scene();

      //renderer
      renderer = new THREE.WebGLRenderer({antialias: true, preserveDrawingBuffer: true});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      window.addEventListener('resize', resize, false);

      //camera
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
      camera.position.set(0, 75, 160);

      //controls
      orbitable = new THREE.OrbitControls(camera, renderer.domElement);
      orbitable.enableDamping = true;
      orbitable.campingFactor = 0.25;
      orbitable.enableZoom = true;
      orbitable.update();

      /**************************
      add  lights to scene
      will be moved Later
      **************************/
      var sphereForLight = new THREE.SphereBufferGeometry(2, 16, 8);

			sphL1 = new THREE.PointLight(0xff0040, 2, 70);
			sphL1.add(new THREE.Mesh(sphereForLight, new THREE.MeshBasicMaterial({color: 0xff0040})));
      scene.add(sphL1);

			sphL2 = new THREE.PointLight(0x0040ff, 2, 70);
			sphL2.add(new THREE.Mesh(sphereForLight, new THREE.MeshBasicMaterial({color: 0x0040ff})));
      scene.add(sphL2);

			sphL3 = new THREE.PointLight(0x80ff80, 2, 70);
			sphL3.add(new THREE.Mesh(sphereForLight, new THREE.MeshBasicMaterial({color: 0x80ff80})));
      scene.add(sphL3);

			sphL4 = new THREE.PointLight(0xffaa00, 2, 70);
			sphL4.add(new THREE.Mesh(sphereForLight, new THREE.MeshBasicMaterial({color: 0xffaa00})));
      scene.add(sphL4);

      sphL5 = new THREE.PointLight(0xffffff, 2, 70);
			sphL5.add(new THREE.Mesh(sphereForLight, new THREE.MeshBasicMaterial({color: 0xffffff})));

      scene.add(sphL5);

      /***************************
      Creating Mirror back, bottom
      and walls of enclosure
      ***************************/

      //back
      var backWallGeom = new THREE.PlaneBufferGeometry(150, 150);
      var backWallMirror = new THREE.Reflector(backWallGeom, {
        clipBias: 0.003,
        textureWidth: window.innerWidth * window.devicePixelRatio,
        textureHeight: window.innerHeight * window.devicePixelRatio,
        color: 0x889998
      });
      //backWallMirror.position.y = 75;
      backWallMirror.position.z = -75;
      scene.add(backWallMirror);

      //generic wall to be reused
      var genWallGeo = new THREE.PlaneBufferGeometry(150, 150);

      //ceiling and floor geom
      var cfGeo = new THREE.PlaneBufferGeometry(150, 150);

      //top WHITE
      var ceiling = new THREE.Mesh(cfGeo, new THREE.MeshPhongMaterial({color: 0xffffff}));
      ceiling.position.y = 75;
      ceiling.rotateX(Math.PI / 2);
      ceiling.receiveShadow = true;
      scene.add(ceiling);

      //floor WHITE
      var floor = new THREE.Mesh(cfGeo, new THREE.MeshPhongMaterial({color: 0xffffff}));
      floor.rotateX(-Math.PI / 2);
      floor.receiveShadow = true;
      floor.position.y = -75;
      scene.add(floor);

      //front White/blue
      var frontWall = new THREE.Mesh(genWallGeo, new THREE.MeshPhongMaterial({color: 0xffffff}));
      frontWall.position.z = 75;
      frontWall.rotateY(Math.PI);
      frontWall.reciveShadow = true;
      scene.add(frontWall);

      //right NOVA blue with light
      var rightWall = new THREE.Mesh(genWallGeo, new THREE.MeshPhongMaterial({color: 0xffffff}));
      rightWall.position.x = 75;
      rightWall.rotateY(-Math.PI / 2);
      rightWall.receiveShadow = true;
      scene.add(rightWall);

      //left NOVA blue with light
      var leftWall = new THREE.Mesh(genWallGeo, new THREE.MeshPhongMaterial({color: 0xffffff}));
      leftWall.position.x = -75;
      leftWall.rotateY(Math.PI / 2);
      leftWall.reciveShadow = true;
      scene.add(leftWall);

      /*******************************
      create water bottom
      *******************************/
      var waterGeom = new THREE.PlaneBufferGeometry(150, 150);
      water = new THREE.Water(waterGeom, {
        color: 0xfffff,
        scale: 1,
        textureWidth: 1024,
        textureHeight: 1024,
        flowDirection: new THREE.Vector2(1, 2)
      });
      water.rotation.x = (Math.PI * (-0.5));
      scene.add(water);

      /************************
      //// TODO: add rings to Scene
      ************************/
      function genTorusRingsAndSphere(radius, numRings) {
        //torus rings with sphere object creation
        torusObj = new THREE.Object3D();

        //CREATE Sphere
        sphereRadius = radius * (2 / 3);
        var sphGeom = new THREE.SphereGeometry(sphereRadius, 32, 32);
        var sphMat = new THREE.MeshBasicMaterial({
          color: 0xffffff
        });
        var centerSphere = new THREE.Mesh(sphGeom, sphMat);

        //add sphere to obj of function
        torusObj.add(centerSphere);

        //generate rings according to parameters given by function call
        for (var i = 0; i < numRings; i++) {
          var torusGeom = new THREE.TorusGeometry(radius, 3, 16, 100);
          var torusColor = new THREE.Color(0xffffff * Math.random()); //.setHSL(randomFloat(0, 1), randomFloat(0.8, 0.95), randomFloat(0.3, 0.7));
          var torusMat = new THREE.MeshBasicMaterial({
            color: torusColor
          });
          var torusMesh = new THREE.Mesh(torusGeom, torusMat);
          radius = radius + 6.5;

          torusObj.add(torusMesh);
        }
        return torusObj;
      }

      var torusRings = genTorusRingsAndSphere(5, 10);
      torusRings.postion(-50, -10, 50);
      scene.add(torusRings);

      /**************************
      ADDS SHARK TO CENTER SCREEN
      **************************/
      var loader = new THREE.OBJLoader();
      loader.setPath('js/models/');
      loader.load('Shark.obj', function (object) {
        object.scale.multiplyScalar(4);
        object.rotateZ = Math.PI / 2;
        object.position.y = -10;
        scene.add(object);
      });

    }

    function resize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      window.requestAnimationFrame(animate);
      render();
    }

    function render() {
      var delta = clock.getDelta();
      var time = Date.now() * 0.0025;
      orbitable.update(delta);

      //light movement
      sphL1.position.x = Math.sin(time * 0.7) * 50;
			sphL1.position.y = Math.cos(time * 0.5) * 60;
			sphL1.position.z = Math.cos(time * 0.3) * 50;

			sphL2.position.x = Math.cos(time * 0.3) * 50;
			sphL2.position.y = Math.sin(time * 0.5) * 60;
			sphL2.position.z = Math.sin(time * 0.7) * 50;

			sphL3.position.x = Math.sin(time * 0.7) * 50;
		  sphL3.position.y = Math.cos(time * 0.3) * 60;
			sphL3.position.z = Math.sin(time * 0.5) * 50;

			sphL4.position.x = Math.sin(time * 0.3) * 50;
			sphL4.position.y = Math.cos(time * 0.7) * 60;
			sphL4.position.z = Math.sin(time * 0.5) * 50;

      sphL5.position.x = Math.sin(time * 0.7) * 70;
			sphL5.position.y = Math.cos(time * 0.3) * 60;
			sphL5.position.z = Math.sin(time * 0.5) * 50;

      //rings movement
      //separate sphere from torusObj
      var sphereChild = torusObj.children[0];
      //movement of sphere at center of torusObj
      sphereChild.position.x = Math.sin(timer * 1) * 100;
      sphereChild.position.y = Math.cos(0);
      sphereChild.position.z = 0;

      //loop to iterate through each ring of torusObj
      //setting rotation speeds for x, y, z
      //all of which are in relation to the index (i, in this case)
      for (var i = 0; i < torusObj.children.length; i++) {
        //defining a child
        var child = torusObj.children[i];
        //rotation rates for x, y, z axes
        child.rotation.x = timer * (i / 4);
        child.rotation.y = timer * (i / 4);
        child.rotation.z = timer * (i / 4);
      }
      renderer.render(scene, camera);
    }

    init();
    animate();

  </script>

</body>

</html>
