<html>
<head>
  <title>Final Project</title>
  <style>
    body {
      margin: 0
    };
    canvas {
      width: 100%, height: 100%
    };
  </style>
</head>

<body>
</script>
  <script src="js/build/three.js"></script>
  <!--script src="js/build/three.module.js"></script-->
  <script src="js/controls/OrbitControls.js"></script>
  <script src="js/modifiers/TessellateModifier.js"></script>
  <script src="js/objects/Water2.js"></script>
  <script src="js/objects/Reflector.js"></script>
  <script src="js/loaders/OBJLoader.js"></script>
  <script src="js/objects/Refractor.js"></script>
  <!--script src="js/objects/Water.js"></script-->

  <script>

    var camera, scene, renderer, object;
    var pLight1, pLight2;
    var orbitable;
    var clock = new THREE.Clock();
    var time = Date.now() * 0.0025;
    var torusObj, sphereRadius;
    var bouy;
    var water;
    var animation;


    //helper function
    function randomInt (min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    //helper function
    function randomFloat(min, max) {
      return Math.random() * (max - min ) + min;
    }


    function init() {
      //scene
      scene = new THREE.Scene();

      //renderer
      renderer = new THREE.WebGLRenderer({antialias: true, preserveDrawingBuffer: true});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      window.addEventListener('resize', resize, false);

      //camera
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
      camera.position.set(0, 75, 160);

      //controls
      orbitable = new THREE.OrbitControls(camera, renderer.domElement);
      orbitable.enableDamping = true;
      orbitable.campingFactor = 0.25;
      orbitable.enableZoom = true;
      orbitable.update();

      /**************************
      add  lights to scene
      **************************/

      var ambientLight = new THREE.AmbientLight(0xb60101, 0.05);
      scene.add(ambientLight);

      var sphereForLight = new THREE.SphereBufferGeometry(2, 16, 8);

			sphL1 = new THREE.PointLight(0x0040ff, 2, 70);
			sphL1.add(new THREE.Mesh(sphereForLight, new THREE.MeshBasicMaterial({color: 0x0040ff})));
      scene.add(sphL1);

			sphL2 = new THREE.PointLight(0x0040ff, 2, 70);
			sphL2.add(new THREE.Mesh(sphereForLight, new THREE.MeshBasicMaterial({color: 0x0040ff})));
      scene.add(sphL2);

			sphL3 = new THREE.PointLight(0x80ff80, 2, 90);
      sphL3.position.y = 30;
			// sphL3.add(new THREE.Mesh(sphereForLight, new THREE.MeshBasicMaterial({color: 0x80ff80})));
      scene.add(sphL3);

			sphL4 = new THREE.PointLight(0xffffff, 2, 70);
			sphL4.add(new THREE.Mesh(sphereForLight, new THREE.MeshBasicMaterial({color: 0xffffff})));
      scene.add(sphL4);

      sphL5 = new THREE.PointLight(0xffffff, 2, 70);
			sphL5.add(new THREE.Mesh(sphereForLight, new THREE.MeshBasicMaterial({color: 0xffffff})));

      scene.add(sphL5);

      /***************************
      Creating Mirror back, bottom
      and walls of enclosure
      ***************************/

      //back
      var backWallGeom = new THREE.PlaneBufferGeometry(150, 150);
      var backWallMirror = new THREE.Reflector(backWallGeom, {
        clipBias: 0.003,
        textureWidth: window.innerWidth * window.devicePixelRatio,
        textureHeight: window.innerHeight * window.devicePixelRatio,
        color: 0x889998
      });
      //backWallMirror.position.y = 75;
      backWallMirror.position.z = -75;
      scene.add(backWallMirror);

      //generic wall to be reused
      var genWallGeo = new THREE.PlaneBufferGeometry(150, 150);

      //ceiling and floor geom
      var cfGeo = new THREE.PlaneBufferGeometry(150, 150);

      //top WHITE
      var ceiling = new THREE.Mesh(cfGeo, new THREE.MeshPhongMaterial({color: 0xffffff}));
      ceiling.position.y = 75;
      ceiling.rotateX(Math.PI / 2);
      ceiling.receiveShadow = true;
      scene.add(ceiling);

      //floor WHITE
      var floor = new THREE.Mesh(cfGeo, new THREE.MeshPhongMaterial({color: 0xffffff}));
      floor.rotateX(-Math.PI / 2);
      floor.receiveShadow = true;
      floor.position.y = -75;
      scene.add(floor);

      //front White/blue
      var frontWall = new THREE.Mesh(genWallGeo, new THREE.MeshPhongMaterial({color: 0xffffff}));
      frontWall.position.z = 75;
      frontWall.rotateY(Math.PI);
      frontWall.reciveShadow = true;
      scene.add(frontWall);

      //right NOVA blue with light
      var rightWall = new THREE.Mesh(genWallGeo, new THREE.MeshPhongMaterial({color: 0xffffff}));
      rightWall.position.x = 75;
      rightWall.rotateY(-Math.PI / 2);
      rightWall.receiveShadow = true;
      scene.add(rightWall);

      //left NOVA blue with light
      var leftWall = new THREE.Mesh(genWallGeo, new THREE.MeshPhongMaterial({color: 0xffffff}));
      leftWall.position.x = -75;
      leftWall.rotateY(Math.PI / 2);
      leftWall.reciveShadow = true;
      scene.add(leftWall);

      /*******************************
      create water bottom
      *******************************/
      var waterGeom = new THREE.PlaneBufferGeometry(150, 150);
      water = new THREE.Water(waterGeom, {
        color: 0xfffff,
        scale: 1,
        textureWidth: 1024,
        textureHeight: 1024,
        flowDirection: new THREE.Vector2(1, 2)
      });
      water.rotation.x = (Math.PI * (-0.5));
      scene.add(water);

      /************************
      adding torus "triangle"
      animation to scene
      ************************/
      function genTorusRingsAndSphere(radius, numRings) {
        //torus rings with sphere object creation
        torusObj = new THREE.Object3D();

        //generate rings according to parameters given by function call
        for (var i = 0; i < numRings; i++) {
          var torusGeom = new THREE.TorusGeometry(radius, 1, 5, 3);
          var torusColor = new THREE.Color(0xffffff);// * Math.random()); //.setHSL(randomFloat(0, 1), randomFloat(0.8, 0.95), randomFloat(0.3, 0.7));
          var torusMat = new THREE.MeshPhongMaterial({
            color: torusColor
          });
          var torusMesh = new THREE.Mesh(torusGeom, torusMat);
          torusMesh.reciveShadow = true;
          radius = radius + 6.5;

          torusObj.add(torusMesh);
        }
        return torusObj;
      }

      var torusRings = genTorusRingsAndSphere(1, 5);
      torusRings.position.y = 30;
      scene.add(torusRings);

      /************************
      ADD CUBE OBJECT THAT WILL
      FLOAT IN WATER...
      ************************/
      bouy = new THREE.Group();

      function getRandomPointOnSphere(rad) {
        rad = rad || 1.0;
        var theta = Math.random() * 2 * Math.PI;
        var phi = Math.acos(2 * Math.random() - 1);
        var x = rad * Math.cos(theta) * Math.sin(phi);
        var y = rad * Math.sin(theta) * Math.sin(phi);
        var z = rad * Math.cos(phi);
        return new THREE.Vector3(x, y, z);
      }

      function starburst(n, innerColor, outerColor, rad = 3) {
        let origin = new THREE.Vector3(0, 0, 0);
        let geom = new THREE.Geometry();
        for (let i = 0; i < n; i++) {
          let dest = getRandomPointOnSphere(rad);
          geom.vertices.push(origin, dest);
          geom.colors.push(innerColor, outerColor);
        }
        let args = {
          vertexColors: true,
          linewidth: 2
        };
        let mat = new THREE.LineBasicMaterial(args);
        return new THREE.Line(geom, mat, THREE.LineSegments);
      }

      for (var i = 0; i < 100; i++) {
        var innerColor = new THREE.Color(0xffffff);
        var outerColor = new THREE.Color(0xffffff);
        var n = 25;
        var matStar = starburst(n, innerColor, outerColor);

        matStar.position.x = Math.random() * 10;
        matStar.position.y = Math.random() * 10;
        matStar.position.z = Math.random() * 10;
        matStar.matrixAutoUpdate = false;
        matStar.updateMatrix();

        bouy.add(matStar);
      }

      bouy.position.x = 50;
      bouy.position.y = -5;
      bouy.position.z = -50;

      scene.add(bouy);

      /**************************
      ADDS SHARK TO CENTER SCREEN
      **************************/
      var loader = new THREE.OBJLoader();
      loader.setPath('js/models/');
      loader.load('Shark.obj', function (object) {
        object.scale.multiplyScalar(4);
        object.rotateZ = Math.PI / 2;
        object.position.y = -10;
        object.position.z = 10;
        scene.add(object);
      });

    }

    function resize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      window.requestAnimationFrame(animate);
      render();
    }

    function render() {
      var delta = clock.getDelta();
      var time = Date.now() * 0.0025;
      orbitable.update(delta);

      //light movement
      sphL1.position.x = Math.sin(time * 0.6) * 50;
			sphL1.position.y = Math.cos(time * 0.4) * 60;
			sphL1.position.z = Math.cos(time * 0.2) * 50;

			sphL2.position.x = Math.cos(time * 0.3) * 50;
			sphL2.position.y = Math.sin(time * 0.5) * 60;
			sphL2.position.z = Math.sin(time * 0.7) * 50;

			// sphL3.position.x = Math.sin(time * 0.7) * 50;
		  // sphL3.position.y = Math.cos(time * 0.3) * 60;
			// sphL3.position.z = Math.sin(time * 0.5) * 50;

			sphL4.position.x = Math.sin(time * 0.6) * 50;
			sphL4.position.y = Math.cos(time * 0.4) * 60;
			sphL4.position.z = Math.sin(time * 0.2) * 50;

      sphL5.position.x = Math.sin(time * 0.7) * 70;
			sphL5.position.y = Math.cos(time * 0.3) * 60;
			sphL5.position.z = Math.sin(time * 0.5) * 50;

      //rings movement
      for (var i = 0; i < torusObj.children.length; i++) {
        //defining a child
        var child = torusObj.children[i];
        //rotation rates for x, y, z axes
        child.rotation.x = time * (i / 10);
        child.rotation.y = time * (i / 10);
        child.rotation.z = time * (i / 10);
      }

      //bouy movement
      bouy.position.x = Math.sin(time * 0.3) * 55;
      bouy.position.z = Math.cos(time * 0.3) * 55;
      renderer.render(scene, camera);
    }

    init();
    animate();

  </script>

</body>

</html>
